# -*- coding: utf-8 -*-
"""weather_prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18cSyNUORmSdyVb-iDYJ6lSPMILi5P1WJ

## Weather data collection
"""

# Weather Data Automate Download(by lavanRaj Anna) API key
try:
  base_path="/content/drive/MyDrive/crop pridiction/Test_weather"
  for y in range(2021,2022):
    for m in range(1,13):
      for n in range(0,32):
        month="{0:0=2d}".format(m)
        ym1= str(y) +'-'+ str(month) + str(n)

        month2="{0:0=2d}".format(m+1)
        ym2= str(y) +'-'+ str(month2) + str(n)

        if(m==12):
          ym2=str(y+1) +"-01-01"

        URL="http://api.worldweatheronline.com/premium/v1/past-weather.ashx?key=7c6af6253f3e429eb95114732210812&q=6.9368,79.8525&date="+ym1+"&enddate="+ym2+"&tp=24&format=json"
        r = requests.get(url = URL)
        data = r.json()

        with open(base_path+"data_"+ym1+".json", 'w') as f:
          json.dump(data, f)
except:
  print("none")

#date cloumn create
df = pd.DataFrame(pd.date_range(start='8/1/2016',end='30/11/2021'), columns = ['date'])
df.to_csv("/content/drive/MyDrive/CROP_PAF/weather_data/weather_data_pettah.csv",index=False)

df=pd.read_csv("/content/drive/MyDrive/CROP_PAF/weather_data/weather_data_pettah.csv")
df["avgtempC"]=''
df["maxtempC"]=''
df["mintempC"]=''
df["sunHour"]=''
df["uvIndex"]=''
df["windspeedKmph"]=''
df["precipMM"]=''
df["avg_precipMM"]=''
df["precipMM"]=''
df["humidity"]=''
df["pressure"]=''
df["DewPointC"]=''
df.head

base_path="/content/drive/MyDrive/CROP_PAF/weather_data/pettah/"
for y in range(2016,2017):
  for m in range(8,13):
    month="{0:0=2d}".format(m)
    path= "data_"+str(y) +'-'+ str(month) +"-01.json"
    f = open(base_path+path)
    data = json.load(f)
    for i in data['data']["weather"]:
      df.loc[df.date==i['date'],'avgtempC']=i['avgtempC']
      df.loc[df.date==i['date'],'maxtempC']=i['maxtempC']
      df.loc[df.date==i['date'],'mintempC']=i['mintempC']
      df.loc[df.date==i['date'],'sunHour']=i['sunHour']
      df.loc[df.date==i['date'],'uvIndex']=i['uvIndex']
      df.loc[df.date==i['date'],'windspeedKmph']=i["hourly"][0]['windspeedKmph']
      df.loc[df.date==i['date'],'precipMM']=float(i["hourly"][0]['precipMM'])*24
      df.loc[df.date==i['date'],'avg_precipMM']=float(i["hourly"][0]['precipMM'])
      df.loc[df.date==i['date'],'humidity']=i["hourly"][0]['humidity']
      df.loc[df.date==i['date'],'pressure']=i["hourly"][0]['pressure']
      df.loc[df.date==i['date'],'DewPointC']=i["hourly"][0]['DewPointC']

dates=[]
for d in dates:
  rr=fshf()=[[45,56],[45,76],[]]
  df.loc[df.date==d,'carr']=rr[0][1]
  df.loc[df.date==d,'carr']=rr[0][1]

df.to_csv("/content/drive/MyDrive/CROP_PAF/weather_data/weather_data_pettah.csv",index=False)

"""## weather Data Analysis and preprocessing"""

from google.colab import drive
drive.mount('/content/drive')

!pip install datetime

!pip install timedelta

!pip install seaborn

import pandas as pd
from datetime import datetime,timedelta
import matplotlib.pyplot as plt
import numpy as np
from statsmodels.tsa.seasonal import seasonal_decompose
import seaborn as sns

"""We have pettah Market srilanka Data from 01-08-2016 to 30-11-2021"""

df = pd.read_csv("/content/drive/MyDrive/crop/Data set/weather_data_pettah_full.csv")
df.head(5)

df.tail()

df.shape

df.info

df.isnull().sum()

df.columns

df.dtypes

df.describe()

print(df.avgtempC.unique())
# print(df.maxtempC.unique())
# print(df.mintempC.unique())
# print(df.sunHour.unique())
# print(df.uvIndex.unique())
# print(df.windspeedKmph.unique())
# print(df.precipMM.unique())
# print(df.avg_precipMM.unique())
# print(df.humidity.unique())
# print(df.pressure.unique())
# print(df.DewPointC.unique())

# sample work
x=[1,2,3,4,5,6,7]
y1=[2,4,6,8,10,12,14]
y2=[1,2,3,4,5,6,7]

plt.subplot(2, 3, 1)
plt.plot(x, y1, 'ko-')
plt.title('Smaple 1')
plt.xlabel('time (s)')
plt.ylabel('temp1')



plt.subplot(2, 3, 2)
plt.plot(x, y2, 'r.-')
plt.title('Smaple 2')
plt.xlabel('time (s)')
plt.ylabel('temp 2')

plt.show()

date_list = df["date"].values.tolist()
avgtempC_list = df["avgtempC"].values.tolist()
maxtempC_list = df["maxtempC"].values.tolist()
mintempC_list = df["mintempC"].values.tolist()
sunHour_list = df["sunHour"].values.tolist()
uvIndex_list = df["uvIndex"].values.tolist()
windspeedKmph_list = df["windspeedKmph"].values.tolist()
precipMM_list = df["precipMM"].values.tolist()
avg_precipMM_list = df["avg_precipMM"].values.tolist()
humidity_list = df["humidity"].values.tolist()
pressure_list = df["pressure"].values.tolist()
DewPointC_list = df["DewPointC"].values.tolist()

print(min(avgtempC_list))
print(max(avgtempC_list))

plt.subplot(6, 2, 1)
plt.plot(date_list, avgtempC_list, 'ko-')
plt.title('Weather_avgtempC')
plt.xlabel('time')
plt.ylabel('avgtempC')


plt.subplot(6, 2, 2)
plt.plot(date_list, maxtempC_list, 'ko-')
plt.title('weather_maxtempC')
plt.xlabel('time')
plt.ylabel('maxtempC')

plt.subplot(6, 2, 3)
plt.plot(date_list, mintempC_list, 'ko-')
plt.title('Weather_mintempC')
plt.xlabel('time')
plt.ylabel('mintempC')

plt.subplot(6, 2, 4)
plt.plot(date_list, sunHour_list, 'r.-')
plt.title('Weather_sunHour')
plt.xlabel('time')
plt.ylabel('sunHour')

plt.subplot(6, 2, 5)
plt.plot(date_list, uvIndex_list, 'r.-')
plt.title('Weather_uvIndex')
plt.xlabel('time')
plt.ylabel('uvIndex')

plt.subplot(6, 2, 6)
plt.plot(date_list, windspeedKmph_list, 'r.-')
plt.title('Weather_windspeedKmph')
plt.xlabel('time')
plt.ylabel('windspeedKmph')

plt.subplot(6, 2, 7)
plt.plot(date_list, precipMM_list, 'ko-')
plt.title('Weather_precipMM')
plt.xlabel('time')
plt.ylabel('precipMM')

plt.subplot(6, 2, 8)
plt.plot(date_list, avg_precipMM_list, 'ko-')
plt.title('Weather_avg_precipMM')
plt.xlabel('time')
plt.ylabel('avg_precipMM')

plt.subplot(6, 2, 9)
plt.plot(date_list, humidity_list, 'r.-')
plt.title('Weather_humidity')
plt.xlabel('time')
plt.ylabel('humidity')

plt.subplot(6, 2, 10)
plt.plot(date_list, pressure_list, 'r.-')
plt.title('Weather_pressure')
plt.xlabel('time')
plt.ylabel('pressure')

plt.subplot(6, 2, 11)
plt.plot(date_list, DewPointC_list, 'r.-')
plt.title('Weather_DewPointC')
plt.xlabel('time')
plt.ylabel('DewPointC')

plt.show()

def graph(x,y1,y2,y3,y4):
  import matplotlib.pyplot as plt
  import numpy as np
  fig, ax = plt.subplots(2, 2, figsize=(20,10))
  # Preparing the data to subplots
  # Plot
  ax[0, 0].plot(x, y1, color='r')
  ax[0, 1].plot(x, y2, color='k')
  ax[1, 0].plot(x, y3, color='y')
  ax[1, 1].plot(x, y4, color='c')
  # Display
  plt.show()

# Weather=[avgtempC_list,maxtempC_list,mintempC_list,sunHour_list,uvIndex_list,windspeedKmph_list,precipMM_list,avg_precipMM_list,humidity_list,pressure_list,DewPointC_list]
graph(date_list,avgtempC_list,maxtempC_list,mintempC_list,sunHour_list)
graph(date_list,uvIndex_list,windspeedKmph_list,precipMM_list,avg_precipMM_list)
graph(date_list,humidity_list,pressure_list,DewPointC_list)

# df['month'] = df.index.month
# df['year'] = df.index.year
# df['day'] = df.index.day
# df.head()

df.columns

df.head()

Weather=['avgtempC','maxtempC','mintempC','sunHour','uvIndex','windspeedKmph','precipMM','avg_precipMM','humidity','pressure','DewPointC']
for i in range(0,11):
  print(Weather[i])
  # df.set_index('date', inplace=True)
  data = df[['date',Weather[i]]]
  data.dropna(inplace=True)
  data.columns = ['ds','y']
  # data.head()
  result = data.dtypes
  print(result)
  # df['date'] = pd.to_datetime(df['date'])
  # df.set_index('date',inplace = True)
  plt.figure(figsize = (20,5))
  sns.lineplot(x="date" , y=str(Weather[i]) , data= df)
  plt.show()

def split_train_test(date,weather):
  data = df[[date,weather]]
  data.dropna(inplace=True)
  data.columns = ['ds','y']
  df[date] = pd.to_datetime(df[date])
  df.set_index(date,inplace = True)
  # data.head()
  df_train = data.iloc[:1600,:]
  df_test = data.iloc[1600:,:]
  print(data.shape)
  print(df_train.shape)
  print(df_test.shape)
  return df_train,df_test

print(split_train_test('date','avgtempC'))

# we only change the Weather parameter
  data = df[['date','avgtempC']]
  data.dropna(inplace=True)
  data.columns = ['ds','y']
  df['date'] = pd.to_datetime(df['date'])
  df.set_index('date',inplace = True)
  # data.head()
  df_train = data.iloc[:1600,:]
  df_test = data.iloc[1600:,:]
  print(data.shape)
  print(df_train.shape)
  print(df_test.shape)

df_train.head()

"""## **Model**"""

!pip install Prophet

!sudo pip install fbprophet

from fbprophet import Prophet

# check prophet version
import fbprophet
# print version number
print('Prophet %s' % fbprophet.__version__)

# define the model
# set the uncertainty interval to 95% (the Prophet default is 80%)
model = Prophet(interval_width=0.95)
# fit the model
model.fit(df_train)

dataTypeSeries = df_train.dtypes
print('Data type of each column of Dataframe :')
print(dataTypeSeries)

future = model.make_future_dataframe(periods=348)
forecast = model.predict(future )
forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(348)

fig1 = model.plot_components(forecast)
fig1

fig2 = model.plot(forecast, uncertainty=True)
fig2

from prophet.plot import plot_plotly, plot_components_plotly
fig3 = plot_plotly(model, forecast)
fig3

"""## **Error calculation**

![image.png](data:image/png;base64,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)
"""

df_test.shape[0]

y = df_test['y'].tolist()
y_pred = forecast['yhat'].values[1600:]
sum=0
for i in range(0,df_test.shape[0]):
  sum += (y[i]-y_pred[i])**2
rmse = (sum/df_test.shape[0])**0.5
print(rmse)

list_of_avgtempC = df_test['y'].tolist()
len(list_of_avgtempC)

y_pred = forecast['yhat'].values[1600:]
len(y_pred)

sum=0
for i in range(0,348):
  sum += (list_of_avgtempC[i]-y_pred[i])**2

rmse = (sum/348)**0.5
rmse